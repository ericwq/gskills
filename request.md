# Send request

gRPC over HTTP 2 use HTTP 2 frames. But how to do that exactly? let's explain the detail of implementation of gRPC request. [gRPC over HTTP2](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md) is a good start point to explain the design of gRPC over HTTP 2. In brief, the gRPC call request is transformed into three parts: 
```
Request → Request-Headers *Length-Prefixed-Message EOS. 
```
* a header frame (***Request-Headers***), 
* zero or more data Frame (***Length-Prefixed-Message***), 
* the final part is ***EOS***(end of stream) is a flag, set in the last data frame.

The following diagram is the invocation sequence. It foucus on the sending request: mainly ***Request-Headers*** and ***Length-Prefixed-Message***.
![images/images.003.png](images/images.003.png)

## Application code
Here is the gRPC client application code snippet. It uses ```c := pb.NewGreeterClient(conn)``` to create the network connection and calls ```r, err := c.SayHello(ctx, &pb.HelloRequest{Name: name})``` to send the request over HTTP 2. Pretty simple, right?

Let's move on to see what happens under the hood.

```go
    // Set up a connection to the server.                                       
    conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())
    if err != nil {                                      
        log.Fatalf("did not connect: %v", err)
    }                                             
    defer conn.Close()                                                                                                                 
    c := pb.NewGreeterClient(conn)
                                         
    // Contact the server and print out its response.      
    name := defaultName              
    if len(os.Args) > 1 {                                                                                                                                    
        name = os.Args[1]      
    }      
    ctx, cancel := context.WithTimeout(context.Background(), time.Second)      
    defer cancel()      
    r, err := c.SayHello(ctx, &pb.HelloRequest{Name: name})      
    if err != nil {                                  
        log.Fatalf("could not greet: %v", err)            
    }                               
    log.Printf("Greeting: %s", r.GetMessage())     
```
## Client stub
```c.SayHello()``` is the gRPC client stub generated by gRPC. This stub provides the ```"/helloworld.Greeter/SayHello"``` parameter and the ```in``` parameter. 

please read the following specification for the method string argument( the canonical name of ```"/helloworld.Greeter/SayHello"```):
* Path → ":path" "/" Service-Name "/" {method name} 
* Service-Name → {IDL-specific service name}

```go
func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) {
    out := new(HelloReply)                 
    err := c.cc.Invoke(ctx, "/helloworld.Greeter/SayHello", in, out, opts...)      
    if err != nil {                           
        return nil, err
    }
    return out, nil
}
```
```Invoke()``` apply the ```CallOptions``` first. If there is any interceptor, use the interceptor to send the request, otherwise directly call the ```invoke()``` function.

```go
   25 // Invoke sends the RPC request on the wire and returns after response is                                                                              
   26 // received.  This is typically called by generated code. 
   27 //                                                                                                           
   28 // All errors returned by Invoke are compatible with the status package.                                 
   29 func (cc *ClientConn) Invoke(ctx context.Context, method string, args, reply interface{}, opts ...CallOption) error {
   30     // allow interceptor to see all applicable call options, which means those             
   31     // configured as defaults from dial option as well as per-call options
   32     opts = combine(cc.dopts.callOptions, opts)                                                                         
   33                                                                                 
   34     if cc.dopts.unaryInt != nil {                                                      
   35         return cc.dopts.unaryInt(ctx, method, args, reply, cc, invoke, opts...)             
   36     }                  
   37     return invoke(ctx, method, args, reply, cc, opts...)             
   38 }                                                                              
```
### Fork road
```invoke()``` create a client stream. Here is the main fork road.
* To send the request, we need a HTTP 2 stream. Besides create the client stream, ```newClientStream``` will process the ***Request-Headers***
* ```cs.SendMsg(req)``` will process the ***Length-Prefixed-Message***, 
* ***EOS*** is just the flag in the last data frame.
* For this case, we will ignore the ```cs.RecvMsg()```. We will explain the detail of server side request process in another chapter. 

```go
func invoke(ctx context.Context, method string, req, reply interface{}, cc *ClientConn, opts ...CallOption) error {
    cs, err := newClientStream(ctx, unaryStreamDesc, cc, method, opts...)
    if err != nil {      
        return err      
    }                                                                                                                                     
    if err := cs.SendMsg(req); err != nil {      
        return err                       
    }                                              
    return cs.RecvMsg(reply)      
}      
```
### Sending Request-Headers
```newClientStream()``` create the ```clientStream```, retry the ```op``` function several times until success or error. ```op``` is a anonymous warpper for the ```a.newStream()``` function, where ```a``` is the ```csAttempt``` just created with ```cs.newAttemptLocked()```

```go
func newClientStream(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, opts ...CallOption) (_ ClientStream, err error) {
...
    cs := &clientStream{  
        callHdr:      callHdr,
        ctx:          ctx,   
        methodConfig: &mc,
        opts:         opts,  
        callInfo:     c,                                                                                                            
        cc:           cc,                                                                                                           
        desc:         desc,                                                                                                         
        codec:        c.codec,                                                                                                      
        cp:           cp,                                                                                                           
        comp:         comp,                                                                                                         
        cancel:       cancel,                                                                                                       
        beginTime:    beginTime,
        firstAttempt: true,                                                                                                         
    }                                                                                                                              
...
    if err := cs.newAttemptLocked(sh, trInfo); err != nil {
        cs.finish(err)
        return nil, err
    }

    op := func(a *csAttempt) error { return a.newStream() }
    if err := cs.withRetry(op, func() { cs.bufferForRetryLocked(0, op) }); err != nil {
        cs.finish(err)
        return nil, err
    }
...
}
```
```a.newStream()``` create the transport stream attempt. ```csAttempt``` is an action can be retried several times untial failure or success. While ```cs.withRetry()``` is a mechanism to perform the "attempt action" with the predefined retry policy.

```go
func (a *csAttempt) newStream() error {       
    cs := a.cs       
    cs.callHdr.PreviousAttempts = cs.numRetries       
    s, err := a.t.NewStream(cs.ctx, cs.callHdr)
    if err != nil {       
        if _, ok := err.(transport.PerformedIOError); ok {
            // Return without converting to an RPC error so retry code can
            // inspect.       
            return err            
        }       
        return toRPCErr(err)     
    }                                            
    cs.attempt.s = s       
    cs.attempt.p = &parser{r: s}       
    return nil       
} 
```
```a.t.NewStream()``` create the header frame and send it with ```t.controlBuf.executeAndPut()```. Now the ***Request-Headers*** has been send. We will not discuss the ```t.controlBuf``` detail. It deserve another chapter.

```go
// NewStream creates a stream and registers it into the transport as "active"
// streams.
func (t *http2Client) NewStream(ctx context.Context, callHdr *CallHdr) (_ *Stream, err error) {
    ctx = peer.NewContext(ctx, t.getPeer())
    headerFields, err := t.createHeaderFields(ctx, callHdr)
    if err != nil {
        // We may have performed I/O in the per-RPC creds callback, so do not
        // allow transparent retry.
        return nil, PerformedIOError{err}
    }
    s := t.newStream(ctx, callHdr)
...
    hdr := &headerFrame{
        hf:        headerFields,
        endStream: false,
        initStream: func(id uint32) error {
...
        },
        onOrphaned: cleanup,
        wq:         s.wq,
    }

    for {
        success, err := t.controlBuf.executeAndPut(func(it interface{}) bool {
            if !checkForStreamQuota(it) {
                return false
            }
            if !checkForHeaderListSize(it) {
                return false
            }
            return true
        }, hdr)
        if err != nil {
            return nil, err
        }
        if success {
            break
        }
        if hdrListSizeErr != nil {
            return nil, hdrListSizeErr
        }
        firstTry = false
        select {
        case <-ch:
        case <-s.ctx.Done():
            return nil, ContextErr(s.ctx.Err())
        case <-t.goAway:
            return nil, errStreamDrain
        case <-t.ctx.Done():
            return nil, ErrConnClosing
        }
    }
    ...
}
```
Here only show part of the code snippet of ```createHeaderFields()``` . In this case, the ```:path``` header field has value ```"/helloworld.Greeter/SayHello"```. Please also note the value of  ```:authority``` and ```content-type``` header field.
```go
func (t *http2Client) createHeaderFields(ctx context.Context, callHdr *CallHdr) ([]hpack.HeaderField, error) {
...
    headerFields := make([]hpack.HeaderField, 0, hfLen)                                                                                                                      
    headerFields = append(headerFields, hpack.HeaderField{Name: ":method", Value: "POST"})                                                                                        
    headerFields = append(headerFields, hpack.HeaderField{Name: ":scheme", Value: t.scheme})                                                                               
    headerFields = append(headerFields, hpack.HeaderField{Name: ":path", Value: callHdr.Method})                                                                                 
    headerFields = append(headerFields, hpack.HeaderField{Name: ":authority", Value: callHdr.Host})                                                                
    headerFields = append(headerFields, hpack.HeaderField{Name: "content-type", Value: grpcutil.ContentType(callHdr.ContentSubtype)})
    headerFields = append(headerFields, hpack.HeaderField{Name: "user-agent", Value: t.userAgent})                                                                                    headerFields = append(headerFields, hpack.HeaderField{Name: "te", Value: "trailers"})
...  
}

```
### Sending Length-Prefixed-Message and EOS
let's go back to the fork road and check the ```cs.SendMsg()```. 

Inside```cs.SendMsg()```, first  ```prepareMsg()``` encode/compress request data. Secondly, you see the ```op``` function and ```cs.withRetry()``` again. Here ```prepareMsg()``` will encode and compress (if required) the request object to byte slice.

```a.sendMsg()``` send the request data. ```csAttempt``` is an action can be retried several times untial failure or success. While ```cs.withRetry()``` is a mechanism to perform the "attempt action" with the predefined retry policy.

please note:
* ```op``` is a anonymous warpper for the ```a.sendMsg()```, where ```a``` is the ```csAttempt``` early created.

```go
func (cs *clientStream) SendMsg(m interface{}) (err error) {
    defer func() {
        if err != nil && err != io.EOF {
            // Call finish on the client stream for errors generated by this SendMsg
            // call, as these indicate problems created by this client.  (Transport
            // errors are converted to an io.EOF error in csAttempt.sendMsg; the real
            // error will be returned from RecvMsg eventually in that case, or be
            // retried.)                                                                                                            
            cs.finish(err)                                                                                                          
        }                                                                                                                           
    }()
    if cs.sentLast {                                                                                                                                             
        return status.Errorf(codes.Internal, "SendMsg called after CloseSend")                                                      
    }                                                                                                                                                           
    if !cs.desc.ClientStreams {                                                                                                           
        cs.sentLast = true                                                                                                                             
    }
    
    // load hdr, payload, data                                                                                                               
    hdr, payload, data, err := prepareMsg(m, cs.codec, cs.cp, cs.comp)                                                                                    
    if err != nil {                                                                                                                                             
        return err                                                                                                                                 
    }
    // TODO(dfawley): should we be checking len(data) instead?
    if len(payload) > *cs.callInfo.maxSendMessageSize {
        return status.Errorf(codes.ResourceExhausted, "trying to send message larger than max (%d vs. %d)", len(payload), *cs.callInfo.maxSendMessageSize)
    }
    msgBytes := data // Store the pointer before setting to nil. For binary logging.
    op := func(a *csAttempt) error {
        err := a.sendMsg(m, hdr, payload, data)
        // nil out the message and uncomp when replaying; they are only needed for
        // stats which is disabled for subsequent attempts.
        m, data = nil, nil
        return err
    }
    err = cs.withRetry(op, func() { cs.bufferForRetryLocked(len(hdr)+len(payload), op) })
    if cs.binlog != nil && err == nil {
        cs.binlog.Log(&binarylog.ClientMessage{
            OnClientSide: true,
            Message:      msgBytes,
        })
    }
    return 
}
```
```a.sendMsg()``` invoke the ```a.t.Write()``` to send the data. note: ```Last``` is true for no-client-stream PRC. that's our ***EOS*** flag. its value is true. Which means it's our last data stream.

```go
func (a *csAttempt) sendMsg(m interface{}, hdr, payld, data []byte) error {
    cs := a.cs                 
    if a.trInfo != nil {  
        a.mu.Lock()                   
        if a.trInfo.tr != nil {
            a.trInfo.tr.LazyLog(&payload{sent: true, msg: m}, true)
        }       
        a.mu.Unlock()       
    }       
    if err := a.t.Write(a.s, hdr, payld, &transport.Options{Last: !cs.desc.ClientStreams}); err != nil {       
        if !cs.desc.ClientStreams {       
            // For non-client-streaming RPCs, we return nil instead of EOF on error       
            // because the generated code requires it.  finish is not called; RecvMsg()       
            // will call it with the stream's status independently.       
            return nil       
        }       
        return io.EOF       
    }       
    if a.statsHandler != nil {       
        a.statsHandler.HandleRPC(cs.ctx, outPayload(true, m, data, payld, time.Now()))       
    }       
    if channelz.IsOn() {       
        a.t.IncrMsgSent()       
    }       
    return nil       
}       
```
```a.t.Write()``` create the data frame and send it with ```t.controlBuf.put(df)```. Now, the ***Length-Prefixed-Message and EOS*** has been send out. We will not discuss the ```t.controlBuf``` detail. It deserve another chapter.

```go
// Write formats the data into HTTP2 data frame(s) and sends it out. The caller
// should proceed only if Write returns nil.       
func (t *http2Client) Write(s *Stream, hdr []byte, data []byte, opts *Options) error {       
    if opts.Last {       
        // If it's the last message, update stream state.       
        if !s.compareAndSwapState(streamActive, streamWriteDone) {          
            return errStreamDone       
        }       
    } else if s.getState() != streamActive {       
        return errStreamDone       
    }          
    df := &dataFrame{       
        streamID:  s.id,       
        endStream: opts.Last,       
        h:         hdr,       
        d:         data,       
    }       
    if hdr != nil || data != nil { // If it's not an empty data frame, check quota.       
        if err := s.wq.get(int32(len(hdr) + len(data))); err != nil {       
            return err       
        }       
    }       
    return t.controlBuf.put(df)       
}       
```
