# Reply with Response

gRPC over HTTP 2 use HTTP 2 frames. But how to do that exactly? let's explain the detail of implementation of server side response. [gRPC over HTTP2](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md) is a good start point to explain the design of gRPC over HTTP 2. In brief, the gRPC call response is transformed into three parts:

```
Response → (Response-Headers *Length-Prefixed-Message Trailers) / Trailers-Only
```

* A header frame (***Response-Headers***),
* Zero or more data frame (***Length-Prefixed-Message***),
* The final part is ***Trailers***. A special kind of header frame which can be sent after the body. These headers allow for metadata that can’t be calculated up front. In special case, Trailers can be send alone. 

Please refer to the [Send Request](request.md) to get more information about the request. After all we need to know the request to give the correct reply.

## Application code

Here is the gRPC server side application code snippet. It uses ```net.Listen("tcp", port)``` to bind the server side listening port. Then it create a gRPC server with ```grpc.NewServer() ``` and register the implementation of ```"helloworld.GreeterServer"``` service on the gRPC server. At last, it uses ```s.Serve(lis)```to serve the the listening port.

Plase note that the ```server.SayHello()``` will be the destination of gRPC request. Which means it will not serve the client side request directly. Let's continue our analysis from ```pb.RegisterGreeterServer()```. Which prepares the necessary configuration for the gRPC call. 

It's easy, right? With the help from protocol buffer encapsulation, the ```server``` implementation is easy. It just implement the ```SayHello()``` method defined by IDL. 

```go
const (                                
    port = ":50051"                                
)                                
                                
// server is used to implement helloworld.GreeterServer.                                
type server struct {                                
    pb.UnimplementedGreeterServer                                
}                                
                                
// SayHello implements helloworld.GreeterServer                                
func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {                                
    log.Printf("Received: %v", in.GetName())                                
    return &pb.HelloReply{Message: "Hello " + in.GetName()}, nil                                
}                                
                                
func main() {                                
    lis, err := net.Listen("tcp", port)                                
    if err != nil {                                
        log.Fatalf("failed to listen: %v", err)                                
    }                                
    s := grpc.NewServer()                                
    pb.RegisterGreeterServer(s, &server{})                                
    if err := s.Serve(lis); err != nil {                                
        log.Fatalf("failed to serve: %v", err)                                
    }                                
}                                
```
## Register Service
Let's move on to see what happens under the hood. The following code is generated by gRPC plugin. ```grpc.ServiceDesc``` is a data structure to store the service related configuration. 

```_Greeter_SayHello_Handler``` is the so called ```methodHandler```. ```methodHandler``` will be called  when the server got the correct gRPC request instead of the ```server.SayHello()``` method you just provided. Why? Because protocol buffer message need to be decoded and lots of features provided by gRPC need to get a chance to run.

```_Greeter_SayHello_Handler``` use ```dec(in)``` to decode the incoming message and construct the HelloRequest object. If any interceptor (chain) exist, it wrap the ```GreeterServer.SayHello()``` with ```UnaryHandler``` and use the ```UnaryHandler``` as parameter to call the interceptor. 

The ```srv.(GreeterServer).SayHello(ctx, in)``` and ```interceptor(ctx, in, info, handler)``` share the same return type. With this design, if there exists any interceptor, it will got a chance to run. See [Interceptor](interceptor.md) for more detail.

```go
func RegisterGreeterServer(s grpc.ServiceRegistrar, srv GreeterServer) {                                
    s.RegisterService(&_Greeter_serviceDesc, srv)                                
}                                
                                
func _Greeter_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error)       {                                                                
    in := new(HelloRequest)                                
    if err := dec(in); err != nil {                                
        return nil, err                                
    }                                
    if interceptor == nil {                                
        return srv.(GreeterServer).SayHello(ctx, in)                                
    }                                
    info := &grpc.UnaryServerInfo{                                
        Server:     srv,                                
        FullMethod: "/helloworld.Greeter/SayHello",                                
    }                                
    handler := func(ctx context.Context, req interface{}) (interface{}, error) {                                
        return srv.(GreeterServer).SayHello(ctx, req.(*HelloRequest))                                
    }                                
    return interceptor(ctx, in, info, handler)                                
}                                
                                
var _Greeter_serviceDesc = grpc.ServiceDesc{                                
    ServiceName: "helloworld.Greeter",                                
    HandlerType: (*GreeterServer)(nil),                                
    Methods: []grpc.MethodDesc{                                
        {                                
            MethodName: "SayHello",                                
            Handler:    _Greeter_SayHello_Handler,                                
        },                                
    },                                
    Streams:  []grpc.StreamDesc{},                                
    Metadata: "examples/helloworld/helloworld/helloworld.proto",                                
}  
...
type methodHandler func(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor UnaryServerInterceptor) (interface{}, error)

// UnaryHandler defines the handler invoked by UnaryServerInterceptor to complete the normal
// execution of a unary RPC. If a UnaryHandler returns an error, it should be produced by the
// status package, or else gRPC will use codes.Unknown as the status code and err.Error() as
// the status message of the RPC.
type UnaryHandler func(ctx context.Context, req interface{}) (interface{}, error)
...
```
```RegisterService()``` first make sure the ```ss``` implement the ```*GreeterServer``` interface. which is defined by the IDL and generated by gRPC. 

```s.register()``` register the service in the gRPC server. it also convert the ```ServiceDesc``` into ```serviceInfo```. 

In gRPC server, the service is mainly registered by the service name, method name and service implementation. When the client send a gRPC request, the client need to provide both the service name and method name in request. see [Send Request](request.md) for more detail.

In this case:
* service name is ```"helloworld.Greeter"```, method name is ```"SayHello"```.
* in ```Server``` struct, the ```services``` is a map, its key is the service name, the value is the ```serviceInfo```.

```go
// RegisterService registers a service and its implementation to the gRPC
// server. It is called from the IDL generated code. This must be called before
// invoking Serve. If ss is non-nil (for legacy code), its type is checked to
// ensure it implements sd.HandlerType.
func (s *Server) RegisterService(sd *ServiceDesc, ss interface{}) {
    if ss != nil {                                      
        ht := reflect.TypeOf(sd.HandlerType).Elem()                                                                    
        st := reflect.TypeOf(ss)           
        if !st.Implements(ht) {                                                                                                 
            logger.Fatalf("grpc: Server.RegisterService found the handler of type %v that does not satisfy %v", st, ht)
        }                     
    }
    s.register(sd, ss) 
}                                                           

func (s *Server) register(sd *ServiceDesc, ss interface{}) {
    s.mu.Lock()                                                                                                          
    defer s.mu.Unlock()                                                                                                     
    s.printf("RegisterService(%q)", sd.ServiceName)
    if s.serve {
        logger.Fatalf("grpc: Server.RegisterService after Server.Serve for %q", sd.ServiceName)
    }
    if _, ok := s.services[sd.ServiceName]; ok {
        logger.Fatalf("grpc: Server.RegisterService found duplicate service registration for %q", sd.ServiceName)
    }
    info := &serviceInfo{
        serviceImpl: ss,
        methods:     make(map[string]*MethodDesc),
        streams:     make(map[string]*StreamDesc),
        mdata:       sd.Metadata,
    }
    for i := range sd.Methods {
        d := &sd.Methods[i]
        info.methods[d.MethodName] = d
    }
    for i := range sd.Streams {
        d := &sd.Streams[i]
        info.streams[d.StreamName] = d
    }
    s.services[sd.ServiceName] = info
}
...
type Server struct {
    opts serverOptions                                                                         
     
    mu       sync.Mutex // guards following     
    lis      map[net.Listener]bool                                                                               
    conns    map[transport.ServerTransport]bool
    serve    bool        
    drain    bool       
    cv       *sync.Cond              // signaled when connections close for GracefulStop
    services map[string]*serviceInfo // service name -> service info
    events   trace.EventLog      
     
    quit               *grpcsync.Event
    done               *grpcsync.Event
    channelzRemoveOnce sync.Once      
    serveWG            sync.WaitGroup // counts active Serve goroutines for GracefulStop
                               
    channelzID int64 // channelz unique identification number
    czData     *channelzData          
     
    serverWorkerChannels []chan *serverWorkerData
}
```

## Serve request

The following diagram is the serve request sequence. It focus on the reply the response: mainly ***Response-Headers***, ***Length-Prefixed-Message*** and ***Trailers***.

![images.004.png](images/images.004.png)

Now everything is ready. let's serve the gRPC request. ```Serve(``` need to be called from your application code. It will be the main goroutine to serve request. 

Its job is:
* wait and accep the incoming connection and 
* start a new goroutine to process the incoming connection. 

The following connection request will not be blocked because of the anonymous goroutine. Here I fold some unrelated code to make it easy to understand our topic.

```go
// Serve accepts incoming connections on the listener lis, creating a new
// ServerTransport and service goroutine for each. The service goroutines
// read gRPC requests and then call the registered handlers to reply to them.
// Serve returns when lis.Accept fails with fatal errors.  lis will be closed when
// this method returns.
// Serve will return a non-nil error unless Stop or GracefulStop is called.
func (s *Server) Serve(lis net.Listener) error {
...
    for {
        rawConn, err := lis.Accept()
        if err != nil {
+-- 31 lines: if ne, ok := err.(interface {····················································································································
        }                       
        tempDelay = 0                 
        // Start a new goroutine to deal with rawConn so we don't stall this Accept
        // loop goroutine.                          
        //              
        // Make sure we account for the goroutine so GracefulStop doesn't nil out
        // s.conns before this conn can be added.
        s.serveWG.Add(1)                                    
        go func() {                
            s.handleRawConn(rawConn)
            s.serveWG.Done()
        }()                                                                 
    }                        
}                                                
```

### Accept connection

```go
```
### Serve stream

```go
```
### Handle stream

```go
```
