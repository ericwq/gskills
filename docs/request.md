# Send request
* [Application code](#application-code)
* [Client stub](#client-stub)
  * [Fork road](#fork-road)
  * [Send Request-Headers](#send-request-headers)
  * [Send Length-Prefixed-Message and EOS](#send-length-prefixed-message-and-eos)

gRPC over HTTP 2 use HTTP 2 frames. But how to do that exactly? let's explain the detail implementation of gRPC call request. [gRPC over HTTP2](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md) is a good start point to explain the design of gRPC over HTTP 2. In brief, the gRPC call request is transformed into three parts: 
```
Request → Request-Headers *Length-Prefixed-Message EOS. 
```
* a header frame (***Request-Headers***), 
* zero or more data Frame (***Length-Prefixed-Message***), 
* the final part is ***EOS***(end of stream) is a flag, set in the last data frame.

The following diagram is the gRPC call request invocation sequence. It foucus on sending gRPC call request: mainly ***Request-Headers*** and ***Length-Prefixed-Message***.
![images/images.003.png](../images/images.003.png)

## Application code
Here is the gRPC client application code snippet. It uses ```pb.NewGreeterClient()``` to create the network connection and uses ```c.SayHello()``` to send the request over HTTP 2. Pretty simple, right?

Let's continue to see what happens under the hood.

```go
    ...
    // Set up a connection to the server.                                       
    conn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())
    if err != nil {                                      
        log.Fatalf("did not connect: %v", err)
    }                                             
    defer conn.Close()                                                                                                                 
    c := pb.NewGreeterClient(conn)
                                         
    // Contact the server and print out its response.      
    name := defaultName              
    if len(os.Args) > 1 {                                                                                                                                    
        name = os.Args[1]      
    }      
    ctx, cancel := context.WithTimeout(context.Background(), time.Second)      
    defer cancel()      
    r, err := c.SayHello(ctx, &pb.HelloRequest{Name: name})      
    if err != nil {                                  
        log.Fatalf("could not greet: %v", err)            
    }                               
    log.Printf("Greeting: %s", r.GetMessage())     
    ...
```
## Client stub
```*greeterClient.SayHello()``` is the gRPC client stub generated by gRPC. In this stub, ```c.cc.Invoke()``` is called. This is a general method which can be used by other client stub. Note the ```method``` parameter has the fix value ```"/helloworld.Greeter/SayHello"```.

Please read the following definition of method parameter( the canonical name of ```"/helloworld.Greeter/SayHello"```):
* Path → ":path" "/" Service-Name "/" {method name} 
* Service-Name → {IDL-specific service name}

```go
func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) {
    out := new(HelloReply)                 
    err := c.cc.Invoke(ctx, "/helloworld.Greeter/SayHello", in, out, opts...)      
    if err != nil {                           
        return nil, err
    }
    return out, nil
}
```
```c.cc.Invoke()``` apply the ```CallOptions``` first. If there is any interceptor ```cc.dopts.unaryInt != nil```, use the interceptor to send the request, otherwise directly call the ```invoke()``` function.

```go
// Invoke sends the RPC request on the wire and returns after response is                                                                              
// received.  This is typically called by generated code. 
//                                                                                                           
// All errors returned by Invoke are compatible with the status package.                                 
func (cc *ClientConn) Invoke(ctx context.Context, method string, args, reply interface{}, opts ...CallOption) error {
    // allow interceptor to see all applicable call options, which means those             
    // configured as defaults from dial option as well as per-call options
    opts = combine(cc.dopts.callOptions, opts)                                                                         
                                                                                
    if cc.dopts.unaryInt != nil {                                                      
        return cc.dopts.unaryInt(ctx, method, args, reply, cc, invoke, opts...)             
    }                  
    return invoke(ctx, method, args, reply, cc, opts...)             
}                                                                              
```
### Fork road
```invoke()``` creates a client stream first, then calls the ```cs.SendMsg()```, finally calls ```cs.RecvMsg()```. That is the main fork road.
* To send the request, we need a HTTP 2 stream. Besides create the client stream, ```newClientStream``` also process the ***Request-Headers***
* ```cs.SendMsg(req)``` will process the ***Length-Prefixed-Message***, 
* ***EOS*** is just the flag in the last data frame.
* For this case, we will ignore the ```cs.RecvMsg()```. We will discuss the server response process in [Send Response](docs/response.md).

```go
func invoke(ctx context.Context, method string, req, reply interface{}, cc *ClientConn, opts ...CallOption) error {
    cs, err := newClientStream(ctx, unaryStreamDesc, cc, method, opts...)
    if err != nil {      
        return err      
    }                                                                                                                                     
    if err := cs.SendMsg(req); err != nil {      
        return err                       
    }                                              
    return cs.RecvMsg(reply)      
}      
```
### Send Request-Headers
```newClientStream()``` create the client stream ```clientStream```, prepares the ```csAttempt``` and retry the ```op``` function several times until success or fail. 

* ```cs.newAttemptLocked()``` creates a ```csAttempt``` and assign it to ```cs.attempt```
  * ```csAttempt``` is an action can be retried several times untial failure or success. 
* ```cs.withRetry()``` is a mechanism to perform the "attempt action" with the predefined retry policy.
* ```op``` is a anonymous warpper function for the ```a.newStream()``` method, 
  * ```a``` is the ```csAttempt``` just created with ```cs.newAttemptLocked()```
  * ```newStream()``` create the client transport stream and use the stream to send the request header frame.

Let's continue discuss the ```newStream()```.

```go
func newClientStream(ctx context.Context, desc *StreamDesc, cc *ClientConn, method string, opts ...CallOption) (_ ClientStream, err error) {
    ...
    cs := &clientStream{  
        callHdr:      callHdr,
        ctx:          ctx,   
        methodConfig: &mc,
        opts:         opts,  
        callInfo:     c,                                                                                                            
        cc:           cc,                                                                                                           
        desc:         desc,                                                                                                         
        codec:        c.codec,                                                                                                      
        cp:           cp,                                                                                                           
        comp:         comp,                                                                                                         
        cancel:       cancel,                                                                                                       
        beginTime:    beginTime,
        firstAttempt: true,                                                                                                         
    }                                                                                                                              
    ...
    // Only this initial attempt has stats/tracing.
    // TODO(dfawley): move to newAttempt when per-attempt stats are implemented.
    if err := cs.newAttemptLocked(sh, trInfo); err != nil {
        cs.finish(err)
        return nil, err
    }

    op := func(a *csAttempt) error { return a.newStream() }
    if err := cs.withRetry(op, func() { cs.bufferForRetryLocked(0, op) }); err != nil {
        cs.finish(err)
        return nil, err
    }
    ...
}

// newAttemptLocked creates a new attempt with a transport.
// If it succeeds, then it replaces clientStream's attempt with this new attempt.
func (cs *clientStream) newAttemptLocked(sh stats.Handler, trInfo *traceInfo) (retErr error) {
    newAttempt := &csAttempt{
        cs:           cs,
        dc:           cs.cc.dopts.dc,       
        statsHandler: sh,      
        trInfo:       trInfo,                         
    }                                             
    defer func() {                          
        if retErr != nil {                                                   
            // This attempt is not set in the clientStream, so it's finish won't
            // be called. Call it here for stats and trace in case they are not
            // nil.                       
            newAttempt.finish(retErr)
        }                                          
    }()                                            
                                     
    if err := cs.ctx.Err(); err != nil {
        return toRPCErr(err)
    }    
                               
    ctx := cs.ctx                                      
    if cs.cc.parsedTarget.Scheme == "xds" {
        // Add extra metadata (metadata that will be added by transport) to context
        // so the balancer can see them.
        ctx = grpcutil.WithExtraMetadata(cs.ctx, metadata.Pairs(
            "content-type", grpcutil.ContentType(cs.callHdr.ContentSubtype),
        ))
    }
    t, done, err := cs.cc.getTransport(ctx, cs.callInfo.failFast, cs.callHdr.Method)
    if err != nil {
        return err
    }
    if trInfo != nil {
        trInfo.firstLine.SetRemoteAddr(t.RemoteAddr())
    }
    newAttempt.t = t
    newAttempt.done = done
    cs.attempt = newAttempt
    return nil
}                   

func (cs *clientStream) withRetry(op func(a *csAttempt) error, onSuccess func()) error {
    cs.mu.Lock()                                                                    
    for {                                             
        if cs.committed {
            cs.mu.Unlock()
            return op(cs.attempt)                          
        }                                                                              
        a := cs.attempt
        cs.mu.Unlock() 
        err := op(a)      
        cs.mu.Lock()                   
        if a != cs.attempt {
            // We started another attempt already.
            continue                           
        }                      
        if err == io.EOF {                                
            <-a.s.Done()                                                  
        }                                 
        if err == nil || (err == io.EOF && a.s.Status().Code() == codes.OK) {
            onSuccess()                        
            cs.mu.Unlock()                         
            return err               
        }
        if err := cs.retryLocked(err); err != nil {
            cs.mu.Unlock()
            return err
        }
    }
}
```

In ```newStream()``` 
* call ```a.t.NewStream()``` to create the header frame and send the header frame to server 
  * in ```a.t.NewStream()```, 
    * calls ```t.createHeaderFields()``` to build the HPACK header fields
    * calls ```t.newStream()``` to create the client transport stream,
    * build the ```headerFrame``` and initialize its fields,
    * calls ```t.controlBuf.executeAndPut()``` to send the header 
  * Now the ***Request-Headers*** has been sent. 
* if ```a.t.NewStream()``` success, ```newStream()``` save the attempt stream ```cs.attempt.s``` and attempt parser ```cs.attempt.p```

Here only show the code snippet of ```NewStream()``` and ```createHeaderFields()``` . 
 * in the ```createHeaderFields()```
   * the ```:path``` header field has value ```"/helloworld.Greeter/SayHello"```. 
   * please also note the value of  ```:authority``` header fileld and ```content-type``` header field.

```t.controlBuf``` deserve another chapter, see [controlBuffer, loopyWriter and framer](control.md) for detail.

```go
func (a *csAttempt) newStream() error {       
    cs := a.cs       
    cs.callHdr.PreviousAttempts = cs.numRetries       
    s, err := a.t.NewStream(cs.ctx, cs.callHdr)
    if err != nil {       
        if _, ok := err.(transport.PerformedIOError); ok {
            // Return without converting to an RPC error so retry code can
            // inspect.       
            return err            
        }       
        return toRPCErr(err)     
    }                                            
    cs.attempt.s = s       
    cs.attempt.p = &parser{r: s}       
    return nil       
} 

// NewStream creates a stream and registers it into the transport as "active"
// streams.
func (t *http2Client) NewStream(ctx context.Context, callHdr *CallHdr) (_ *Stream, err error) {
    ctx = peer.NewContext(ctx, t.getPeer())
    headerFields, err := t.createHeaderFields(ctx, callHdr)
    if err != nil {
        // We may have performed I/O in the per-RPC creds callback, so do not
        // allow transparent retry.
        return nil, PerformedIOError{err}
    }
    s := t.newStream(ctx, callHdr)
    ...
    hdr := &headerFrame{
        hf:        headerFields,
        endStream: false,
        initStream: func(id uint32) error {
        ...
        },
        onOrphaned: cleanup,
        wq:         s.wq,
    }

    for {
        success, err := t.controlBuf.executeAndPut(func(it interface{}) bool {
            if !checkForStreamQuota(it) {
                return false
            }
            if !checkForHeaderListSize(it) {
                return false
            }
            return true
        }, hdr)
        if err != nil {
            return nil, err
        }
        if success {
            break
        }
        if hdrListSizeErr != nil {
            return nil, hdrListSizeErr
        }
        firstTry = false
        select {
        case <-ch:
        case <-s.ctx.Done():
            return nil, ContextErr(s.ctx.Err())
        case <-t.goAway:
            return nil, errStreamDrain
        case <-t.ctx.Done():
            return nil, ErrConnClosing
        }
    }
    ...
}

func (t *http2Client) createHeaderFields(ctx context.Context, callHdr *CallHdr) ([]hpack.HeaderField, error) {
    ...
    headerFields := make([]hpack.HeaderField, 0, hfLen)                                                                                                                 
    headerFields = append(headerFields, hpack.HeaderField{Name: ":method", Value: "POST"})             
    headerFields = append(headerFields, hpack.HeaderField{Name: ":scheme", Value: t.scheme})     
    headerFields = append(headerFields, hpack.HeaderField{Name: ":path", Value: callHdr.Method})      
    headerFields = append(headerFields, hpack.HeaderField{Name: ":authority", Value: callHdr.Host})      
    headerFields = append(headerFields, hpack.HeaderField{Name: "content-type", Value: grpcutil.ContentType(callHdr.ContentSubtype)})
    headerFields = append(headerFields, hpack.HeaderField{Name: "user-agent", Value: t.userAgent})                        
    headerFields = append(headerFields, hpack.HeaderField{Name: "te", Value: "trailers"})
    ...  
}

```
### Send Length-Prefixed-Message and EOS
let's back to the [Fork road](#fork-road) and check the ```cs.SendMsg()```. 

In ```cs.SendMsg()```, 
* calls  ```prepareMsg()``` to encode and compress (if required) the gRPC call request parameter to byte slice.
* here you can see the ```op``` function and ```cs.withRetry()``` structure again. 
  * ```csAttempt``` is an action can be retried several times untial failure or success. 
  * ```cs.withRetry()``` is a mechanism to perform the "attempt action" with the predefined retry policy.
* ```op``` is a anonymous warpper function for the ```a.sendMsg()``` method, 
  * where ```a``` is the ```csAttempt``` created before,
  * ```a.sendMsg()``` is called to send the gRPC call request parameter.

In ```a.sendMsg()``` 
* calls ```a.t.Write()``` to send the gRPC call request parameter
  * in ```a.t.Write()```,
    * build the ```dataFrame``` and initialize its fields,
    * calls ```t.controlBuf.put()``` to send the parameter
  * now the ***Length-Prefixed-Message*** has been sent
* note ```&transport.Options{Last: !cs.desc.ClientStreams}```, ```Last``` field is true which means this write is the last piece for this stream.
* that means our ***EOS*** flag is already set. 

```t.controlBuf``` deserve another chapter, see [controlBuffer, loopyWriter and framer](control.md) for detail.

```go
func (cs *clientStream) SendMsg(m interface{}) (err error) {
    defer func() {
        if err != nil && err != io.EOF {
            // Call finish on the client stream for errors generated by this SendMsg
            // call, as these indicate problems created by this client.  (Transport
            // errors are converted to an io.EOF error in csAttempt.sendMsg; the real
            // error will be returned from RecvMsg eventually in that case, or be
            // retried.)                                                                                                            
            cs.finish(err)                                                                                                          
        }                                                                                                                           
    }()
    if cs.sentLast {                                                                                                                                             
        return status.Errorf(codes.Internal, "SendMsg called after CloseSend")                                                      
    }                                                                                                                                                           
    if !cs.desc.ClientStreams {                                                                                                           
        cs.sentLast = true                                                                                                                             
    }
    
    // load hdr, payload, data                                                                                                               
    hdr, payload, data, err := prepareMsg(m, cs.codec, cs.cp, cs.comp)                                                                                    
    if err != nil {                                                                                                                                             
        return err                                                                                                                                 
    }
    // TODO(dfawley): should we be checking len(data) instead?
    if len(payload) > *cs.callInfo.maxSendMessageSize {
        return status.Errorf(codes.ResourceExhausted, "trying to send message larger than max (%d vs. %d)", len(payload), *cs.callInfo.maxSendMessageSize)
    }
    msgBytes := data // Store the pointer before setting to nil. For binary logging.
    op := func(a *csAttempt) error {
        err := a.sendMsg(m, hdr, payload, data)
        // nil out the message and uncomp when replaying; they are only needed for
        // stats which is disabled for subsequent attempts.
        m, data = nil, nil
        return err
    }
    err = cs.withRetry(op, func() { cs.bufferForRetryLocked(len(hdr)+len(payload), op) })
    if cs.binlog != nil && err == nil {
        cs.binlog.Log(&binarylog.ClientMessage{
            OnClientSide: true,
            Message:      msgBytes,
        })
    }
    return 
}

func (a *csAttempt) sendMsg(m interface{}, hdr, payld, data []byte) error {
    cs := a.cs                 
    if a.trInfo != nil {  
        a.mu.Lock()                   
        if a.trInfo.tr != nil {
            a.trInfo.tr.LazyLog(&payload{sent: true, msg: m}, true)
        }       
        a.mu.Unlock()       
    }       
    if err := a.t.Write(a.s, hdr, payld, &transport.Options{Last: !cs.desc.ClientStreams}); err != nil {       
        if !cs.desc.ClientStreams {       
            // For non-client-streaming RPCs, we return nil instead of EOF on error       
            // because the generated code requires it.  finish is not called; RecvMsg()       
            // will call it with the stream's status independently.       
            return nil       
        }       
        return io.EOF       
    }       
    if a.statsHandler != nil {       
        a.statsHandler.HandleRPC(cs.ctx, outPayload(true, m, data, payld, time.Now()))       
    }       
    if channelz.IsOn() {       
        a.t.IncrMsgSent()       
    }       
    return nil       
}       

// Write formats the data into HTTP2 data frame(s) and sends it out. The caller
// should proceed only if Write returns nil.       
func (t *http2Client) Write(s *Stream, hdr []byte, data []byte, opts *Options) error {       
    if opts.Last {       
        // If it's the last message, update stream state.       
        if !s.compareAndSwapState(streamActive, streamWriteDone) {          
            return errStreamDone       
        }       
    } else if s.getState() != streamActive {       
        return errStreamDone       
    }          
    df := &dataFrame{       
        streamID:  s.id,       
        endStream: opts.Last,       
        h:         hdr,       
        d:         data,       
    }       
    if hdr != nil || data != nil { // If it's not an empty data frame, check quota.       
        if err := s.wq.get(int32(len(hdr) + len(data))); err != nil {       
            return err       
        }       
    }       
    return t.controlBuf.put(df)       
}       

```
